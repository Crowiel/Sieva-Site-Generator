// Generated from src\content\blog\demo-typescript-best-practices.mdx
export const frontmatter = {
  "title": "TypeScript Best Practices for Large Projects",
  "date": "2024-09-10",
  "description": "Proven patterns and practices for maintaining type safety and code quality in large-scale TypeScript applications.",
  "tags": [
    "web development",
    "typescript",
    "best practices",
    "software architecture"
  ],
  "featured": false
};
export const content = "\r\n# TypeScript Best Practices for Large Projects\r\n\r\nTypeScript has become the de facto standard for large-scale JavaScript applications. Here are the patterns and practices that have helped me maintain sanity in complex codebases.\r\n\r\n## Type Safety Foundations\r\n\r\n### 1. Strict Mode is Non-Negotiable\r\n\r\n```json\r\n// tsconfig.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"strict\": true,\r\n    \"noImplicitAny\": true,\r\n    \"strictNullChecks\": true,\r\n    \"strictFunctionTypes\": true,\r\n    \"noImplicitThis\": true,\r\n    \"alwaysStrict\": true\r\n  }\r\n}\r\n```\r\n\r\n### 2. Avoid `any` Like the Plague\r\n\r\nInstead of:\r\n```typescript\r\nfunction processData(data: any) {\r\n  return data.value;\r\n}\r\n```\r\n\r\nUse proper types:\r\n```typescript\r\ninterface DataStructure {\r\n  value: string;\r\n  timestamp: number;\r\n}\r\n\r\nfunction processData(data: DataStructure) {\r\n  return data.value;\r\n}\r\n```\r\n\r\n### 3. Use `unknown` for Truly Unknown Types\r\n\r\n```typescript\r\nfunction parseJSON(jsonString: string): unknown {\r\n  return JSON.parse(jsonString);\r\n}\r\n\r\n// Force type checking before use\r\nconst data = parseJSON('{\"name\": \"John\"}');\r\nif (typeof data === 'object' && data !== null && 'name' in data) {\r\n  console.log(data.name);\r\n}\r\n```\r\n\r\n## Advanced Type Patterns\r\n\r\n### Discriminated Unions\r\n\r\nPerfect for state management:\r\n\r\n```typescript\r\ntype LoadingState = \r\n  | { status: 'idle' }\r\n  | { status: 'loading' }\r\n  | { status: 'success'; data: string[] }\r\n  | { status: 'error'; error: Error };\r\n\r\nfunction handleState(state: LoadingState) {\r\n  switch(state.status) {\r\n    case 'idle':\r\n      return 'Not started';\r\n    case 'loading':\r\n      return 'Loading...';\r\n    case 'success':\r\n      return state.data.join(', '); // TypeScript knows data exists\r\n    case 'error':\r\n      return state.error.message; // TypeScript knows error exists\r\n  }\r\n}\r\n```\r\n\r\n### Utility Types\r\n\r\n```typescript\r\n// Pick only needed properties\r\ntype UserPreview = Pick<User, 'id' | 'name' | 'avatar'>;\r\n\r\n// Make all properties optional\r\ntype PartialUser = Partial<User>;\r\n\r\n// Make all properties required\r\ntype RequiredUser = Required<User>;\r\n\r\n// Exclude properties\r\ntype UserWithoutPassword = Omit<User, 'password'>;\r\n\r\n// Create types from values\r\nconst CONFIG = {\r\n  development: 'dev',\r\n  staging: 'stg',\r\n  production: 'prod'\r\n} as const;\r\n\r\ntype Environment = typeof CONFIG[keyof typeof CONFIG];\r\n// type Environment = \"dev\" | \"stg\" | \"prod\"\r\n```\r\n\r\n### Generic Constraints\r\n\r\n```typescript\r\ninterface HasId {\r\n  id: string;\r\n}\r\n\r\nfunction findById<T extends HasId>(items: T[], id: string): T | undefined {\r\n  return items.find(item => item.id === id);\r\n}\r\n\r\n// Works with any type that has an id\r\nconst user = findById(users, '123');\r\nconst product = findById(products, '456');\r\n```\r\n\r\n## Project Organization\r\n\r\n### Domain-Driven Structure\r\n\r\n```\r\nsrc/\r\n├── domains/\r\n│   ├── users/\r\n│   │   ├── types.ts\r\n│   │   ├── api.ts\r\n│   │   ├── hooks.ts\r\n│   │   └── utils.ts\r\n│   ├── products/\r\n│   └── orders/\r\n├── shared/\r\n│   ├── types/\r\n│   ├── utils/\r\n│   └── components/\r\n└── config/\r\n```\r\n\r\n### Centralized Type Definitions\r\n\r\n```typescript\r\n// shared/types/api.ts\r\nexport interface ApiResponse<T> {\r\n  data: T;\r\n  status: number;\r\n  message?: string;\r\n}\r\n\r\nexport interface PaginatedResponse<T> extends ApiResponse<T[]> {\r\n  pagination: {\r\n    page: number;\r\n    pageSize: number;\r\n    total: number;\r\n  };\r\n}\r\n\r\n// Usage\r\ntype UsersResponse = PaginatedResponse<User>;\r\n```\r\n\r\n## Error Handling\r\n\r\n### Type-Safe Error Handling\r\n\r\n```typescript\r\nclass AppError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public code: string,\r\n    public statusCode: number = 500\r\n  ) {\r\n    super(message);\r\n    this.name = 'AppError';\r\n  }\r\n}\r\n\r\nclass ValidationError extends AppError {\r\n  constructor(message: string) {\r\n    super(message, 'VALIDATION_ERROR', 400);\r\n  }\r\n}\r\n\r\nfunction handleError(error: unknown): string {\r\n  if (error instanceof ValidationError) {\r\n    return `Validation failed: ${error.message}`;\r\n  }\r\n  if (error instanceof AppError) {\r\n    return `Error ${error.code}: ${error.message}`;\r\n  }\r\n  if (error instanceof Error) {\r\n    return error.message;\r\n  }\r\n  return 'An unknown error occurred';\r\n}\r\n```\r\n\r\n## API Integration\r\n\r\n### Type-Safe API Client\r\n\r\n```typescript\r\ninterface ApiEndpoints {\r\n  '/users': {\r\n    GET: { response: User[] };\r\n    POST: { body: CreateUserDto; response: User };\r\n  };\r\n  '/users/:id': {\r\n    GET: { response: User };\r\n    PUT: { body: UpdateUserDto; response: User };\r\n    DELETE: { response: void };\r\n  };\r\n}\r\n\r\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\r\n\r\nasync function apiCall<\r\n  Path extends keyof ApiEndpoints,\r\n  Method extends keyof ApiEndpoints[Path] & HttpMethod\r\n>(\r\n  path: Path,\r\n  method: Method,\r\n  options?: ApiEndpoints[Path][Method] extends { body: infer B } ? { body: B } : never\r\n): Promise<ApiEndpoints[Path][Method] extends { response: infer R } ? R : never> {\r\n  // Implementation\r\n  throw new Error('Not implemented');\r\n}\r\n\r\n// Usage - fully type-safe!\r\nconst users = await apiCall('/users', 'GET');\r\nconst newUser = await apiCall('/users', 'POST', { \r\n  body: { name: 'John', email: 'john@example.com' } \r\n});\r\n```\r\n\r\n## Performance Tips\r\n\r\n### 1. Use `const` Assertions\r\n\r\n```typescript\r\n// Without const assertion\r\nconst colors = ['red', 'green', 'blue'];\r\n// type: string[]\r\n\r\n// With const assertion\r\nconst colors = ['red', 'green', 'blue'] as const;\r\n// type: readonly [\"red\", \"green\", \"blue\"]\r\n```\r\n\r\n### 2. Lazy Type Inference\r\n\r\n```typescript\r\n// Avoid\r\nconst data: ComplexType = await fetchData();\r\n\r\n// Better - let TypeScript infer\r\nconst data = await fetchData();\r\n// TypeScript infers the type automatically\r\n```\r\n\r\n## Testing\r\n\r\n### Type-Safe Test Utilities\r\n\r\n```typescript\r\nimport { expect, test } from 'vitest';\r\n\r\nfunction expectType<T>(value: T): void {}\r\n\r\ntest('user object has correct shape', () => {\r\n  const user = createUser();\r\n  \r\n  // Runtime check\r\n  expect(user).toHaveProperty('id');\r\n  \r\n  // Compile-time check\r\n  expectType<User>(user);\r\n});\r\n```\r\n\r\n## Common Pitfalls\r\n\r\n### 1. Over-Engineering Types\r\n\r\n```typescript\r\n// Bad - too complex\r\ntype SuperComplexType<T extends Record<string, any>> = {\r\n  [K in keyof T]: T[K] extends Function \r\n    ? ReturnType<T[K]> \r\n    : T[K] extends object \r\n      ? SuperComplexType<T[K]> \r\n      : T[K];\r\n};\r\n\r\n// Good - simple and clear\r\ntype SimplifiedType<T> = {\r\n  [K in keyof T]: T[K];\r\n};\r\n```\r\n\r\n### 2. Not Using Enums Wisely\r\n\r\n```typescript\r\n// Prefer union types over enums\r\ntype Status = 'pending' | 'approved' | 'rejected';\r\n\r\n// Instead of\r\nenum Status {\r\n  Pending = 'pending',\r\n  Approved = 'approved',\r\n  Rejected = 'rejected'\r\n}\r\n```\r\n\r\n## Conclusion\r\n\r\nTypeScript's power comes from its type system. Use it wisely:\r\n\r\n1. **Start strict** - Enable all strict checks\r\n2. **Think in types** - Model your domain accurately\r\n3. **Keep it simple** - Don't over-engineer\r\n4. **Document with types** - They're self-documenting\r\n5. **Test types** - Use tools like `tsd` for type tests\r\n\r\nThe goal is code that's impossible to misuse, not just correct code.\r\n\r\nHappy typing! ⌨️\r\n";
export const html = "<h1>TypeScript Best Practices for Large Projects</h1>\n<p>TypeScript has become the de facto standard for large-scale JavaScript applications. Here are the patterns and practices that have helped me maintain sanity in complex codebases.</p>\n<h2>Type Safety Foundations</h2>\n<h3>1. Strict Mode is Non-Negotiable</h3>\n<pre><code class=\"language-json\">// tsconfig.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"strict\": true,\r\n    \"noImplicitAny\": true,\r\n    \"strictNullChecks\": true,\r\n    \"strictFunctionTypes\": true,\r\n    \"noImplicitThis\": true,\r\n    \"alwaysStrict\": true\r\n  }\r\n}\n</code></pre>\n<h3>2. Avoid <code>any</code> Like the Plague</h3>\n<p>Instead of:</p>\n<pre><code class=\"language-typescript\">function processData(data: any) {\r\n  return data.value;\r\n}\n</code></pre>\n<p>Use proper types:</p>\n<pre><code class=\"language-typescript\">interface DataStructure {\r\n  value: string;\r\n  timestamp: number;\r\n}\r\n\r\nfunction processData(data: DataStructure) {\r\n  return data.value;\r\n}\n</code></pre>\n<h3>3. Use <code>unknown</code> for Truly Unknown Types</h3>\n<pre><code class=\"language-typescript\">function parseJSON(jsonString: string): unknown {\r\n  return JSON.parse(jsonString);\r\n}\r\n\r\n// Force type checking before use\r\nconst data = parseJSON('{\"name\": \"John\"}');\r\nif (typeof data === 'object' &#x26;&#x26; data !== null &#x26;&#x26; 'name' in data) {\r\n  console.log(data.name);\r\n}\n</code></pre>\n<h2>Advanced Type Patterns</h2>\n<h3>Discriminated Unions</h3>\n<p>Perfect for state management:</p>\n<pre><code class=\"language-typescript\">type LoadingState = \r\n  | { status: 'idle' }\r\n  | { status: 'loading' }\r\n  | { status: 'success'; data: string[] }\r\n  | { status: 'error'; error: Error };\r\n\r\nfunction handleState(state: LoadingState) {\r\n  switch(state.status) {\r\n    case 'idle':\r\n      return 'Not started';\r\n    case 'loading':\r\n      return 'Loading...';\r\n    case 'success':\r\n      return state.data.join(', '); // TypeScript knows data exists\r\n    case 'error':\r\n      return state.error.message; // TypeScript knows error exists\r\n  }\r\n}\n</code></pre>\n<h3>Utility Types</h3>\n<pre><code class=\"language-typescript\">// Pick only needed properties\r\ntype UserPreview = Pick&#x3C;User, 'id' | 'name' | 'avatar'>;\r\n\r\n// Make all properties optional\r\ntype PartialUser = Partial&#x3C;User>;\r\n\r\n// Make all properties required\r\ntype RequiredUser = Required&#x3C;User>;\r\n\r\n// Exclude properties\r\ntype UserWithoutPassword = Omit&#x3C;User, 'password'>;\r\n\r\n// Create types from values\r\nconst CONFIG = {\r\n  development: 'dev',\r\n  staging: 'stg',\r\n  production: 'prod'\r\n} as const;\r\n\r\ntype Environment = typeof CONFIG[keyof typeof CONFIG];\r\n// type Environment = \"dev\" | \"stg\" | \"prod\"\n</code></pre>\n<h3>Generic Constraints</h3>\n<pre><code class=\"language-typescript\">interface HasId {\r\n  id: string;\r\n}\r\n\r\nfunction findById&#x3C;T extends HasId>(items: T[], id: string): T | undefined {\r\n  return items.find(item => item.id === id);\r\n}\r\n\r\n// Works with any type that has an id\r\nconst user = findById(users, '123');\r\nconst product = findById(products, '456');\n</code></pre>\n<h2>Project Organization</h2>\n<h3>Domain-Driven Structure</h3>\n<pre><code>src/\r\n├── domains/\r\n│   ├── users/\r\n│   │   ├── types.ts\r\n│   │   ├── api.ts\r\n│   │   ├── hooks.ts\r\n│   │   └── utils.ts\r\n│   ├── products/\r\n│   └── orders/\r\n├── shared/\r\n│   ├── types/\r\n│   ├── utils/\r\n│   └── components/\r\n└── config/\n</code></pre>\n<h3>Centralized Type Definitions</h3>\n<pre><code class=\"language-typescript\">// shared/types/api.ts\r\nexport interface ApiResponse&#x3C;T> {\r\n  data: T;\r\n  status: number;\r\n  message?: string;\r\n}\r\n\r\nexport interface PaginatedResponse&#x3C;T> extends ApiResponse&#x3C;T[]> {\r\n  pagination: {\r\n    page: number;\r\n    pageSize: number;\r\n    total: number;\r\n  };\r\n}\r\n\r\n// Usage\r\ntype UsersResponse = PaginatedResponse&#x3C;User>;\n</code></pre>\n<h2>Error Handling</h2>\n<h3>Type-Safe Error Handling</h3>\n<pre><code class=\"language-typescript\">class AppError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public code: string,\r\n    public statusCode: number = 500\r\n  ) {\r\n    super(message);\r\n    this.name = 'AppError';\r\n  }\r\n}\r\n\r\nclass ValidationError extends AppError {\r\n  constructor(message: string) {\r\n    super(message, 'VALIDATION_ERROR', 400);\r\n  }\r\n}\r\n\r\nfunction handleError(error: unknown): string {\r\n  if (error instanceof ValidationError) {\r\n    return `Validation failed: ${error.message}`;\r\n  }\r\n  if (error instanceof AppError) {\r\n    return `Error ${error.code}: ${error.message}`;\r\n  }\r\n  if (error instanceof Error) {\r\n    return error.message;\r\n  }\r\n  return 'An unknown error occurred';\r\n}\n</code></pre>\n<h2>API Integration</h2>\n<h3>Type-Safe API Client</h3>\n<pre><code class=\"language-typescript\">interface ApiEndpoints {\r\n  '/users': {\r\n    GET: { response: User[] };\r\n    POST: { body: CreateUserDto; response: User };\r\n  };\r\n  '/users/:id': {\r\n    GET: { response: User };\r\n    PUT: { body: UpdateUserDto; response: User };\r\n    DELETE: { response: void };\r\n  };\r\n}\r\n\r\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\r\n\r\nasync function apiCall&#x3C;\r\n  Path extends keyof ApiEndpoints,\r\n  Method extends keyof ApiEndpoints[Path] &#x26; HttpMethod\r\n>(\r\n  path: Path,\r\n  method: Method,\r\n  options?: ApiEndpoints[Path][Method] extends { body: infer B } ? { body: B } : never\r\n): Promise&#x3C;ApiEndpoints[Path][Method] extends { response: infer R } ? R : never> {\r\n  // Implementation\r\n  throw new Error('Not implemented');\r\n}\r\n\r\n// Usage - fully type-safe!\r\nconst users = await apiCall('/users', 'GET');\r\nconst newUser = await apiCall('/users', 'POST', { \r\n  body: { name: 'John', email: 'john@example.com' } \r\n});\n</code></pre>\n<h2>Performance Tips</h2>\n<h3>1. Use <code>const</code> Assertions</h3>\n<pre><code class=\"language-typescript\">// Without const assertion\r\nconst colors = ['red', 'green', 'blue'];\r\n// type: string[]\r\n\r\n// With const assertion\r\nconst colors = ['red', 'green', 'blue'] as const;\r\n// type: readonly [\"red\", \"green\", \"blue\"]\n</code></pre>\n<h3>2. Lazy Type Inference</h3>\n<pre><code class=\"language-typescript\">// Avoid\r\nconst data: ComplexType = await fetchData();\r\n\r\n// Better - let TypeScript infer\r\nconst data = await fetchData();\r\n// TypeScript infers the type automatically\n</code></pre>\n<h2>Testing</h2>\n<h3>Type-Safe Test Utilities</h3>\n<pre><code class=\"language-typescript\">import { expect, test } from 'vitest';\r\n\r\nfunction expectType&#x3C;T>(value: T): void {}\r\n\r\ntest('user object has correct shape', () => {\r\n  const user = createUser();\r\n  \r\n  // Runtime check\r\n  expect(user).toHaveProperty('id');\r\n  \r\n  // Compile-time check\r\n  expectType&#x3C;User>(user);\r\n});\n</code></pre>\n<h2>Common Pitfalls</h2>\n<h3>1. Over-Engineering Types</h3>\n<pre><code class=\"language-typescript\">// Bad - too complex\r\ntype SuperComplexType&#x3C;T extends Record&#x3C;string, any>> = {\r\n  [K in keyof T]: T[K] extends Function \r\n    ? ReturnType&#x3C;T[K]> \r\n    : T[K] extends object \r\n      ? SuperComplexType&#x3C;T[K]> \r\n      : T[K];\r\n};\r\n\r\n// Good - simple and clear\r\ntype SimplifiedType&#x3C;T> = {\r\n  [K in keyof T]: T[K];\r\n};\n</code></pre>\n<h3>2. Not Using Enums Wisely</h3>\n<pre><code class=\"language-typescript\">// Prefer union types over enums\r\ntype Status = 'pending' | 'approved' | 'rejected';\r\n\r\n// Instead of\r\nenum Status {\r\n  Pending = 'pending',\r\n  Approved = 'approved',\r\n  Rejected = 'rejected'\r\n}\n</code></pre>\n<h2>Conclusion</h2>\n<p>TypeScript's power comes from its type system. Use it wisely:</p>\n<ol>\n<li><strong>Start strict</strong> - Enable all strict checks</li>\n<li><strong>Think in types</strong> - Model your domain accurately</li>\n<li><strong>Keep it simple</strong> - Don't over-engineer</li>\n<li><strong>Document with types</strong> - They're self-documenting</li>\n<li><strong>Test types</strong> - Use tools like <code>tsd</code> for type tests</li>\n</ol>\n<p>The goal is code that's impossible to misuse, not just correct code.</p>\n<p>Happy typing! ⌨️</p>";
export const slug = "demo-typescript-best-practices";
export const type = "blog";

export default {
  frontmatter,
  content,
  html,
  slug,
  type
};

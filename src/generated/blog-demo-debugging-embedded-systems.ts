// Generated from src\content\blog\demo-debugging-embedded-systems.mdx
export const frontmatter = {
  "title": "Debugging Embedded Systems: Tips and Tools",
  "date": "2024-10-01",
  "description": "Essential debugging techniques and tools for embedded systems development, from serial debugging to logic analyzers.",
  "tags": [
    "embedded systems",
    "debugging",
    "hardware",
    "tools"
  ],
  "featured": false
};
export const content = "\r\n# Debugging Embedded Systems: Tips and Tools\r\n\r\nDebugging embedded systems presents unique challenges compared to traditional software development. Here's a comprehensive guide to the essential techniques and tools.\r\n\r\n## The Debugging Toolkit\r\n\r\n### 1. Serial Debugging: Your First Line of Defense\r\n\r\n```cpp\r\n// ESP32 example\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  Serial.println(\"System starting...\");\r\n}\r\n\r\nvoid loop() {\r\n  int sensorValue = analogRead(A0);\r\n  Serial.printf(\"Sensor: %d, Free heap: %d\\n\", \r\n                sensorValue, ESP.getFreeHeap());\r\n  delay(1000);\r\n}\r\n```\r\n\r\n**Pro tip**: Use structured logging with prefixes:\r\n```cpp\r\n#define DEBUG_SENSOR \"[SENSOR] \"\r\n#define DEBUG_NETWORK \"[NET] \"\r\n#define DEBUG_ERROR \"[ERROR] \"\r\n\r\nSerial.println(DEBUG_SENSOR \"Temperature: 25.4¬∞C\");\r\n```\r\n\r\n### 2. LED Debugging: When Serial Isn't Available\r\n\r\nThe humble LED can save hours of debugging:\r\n\r\n```cpp\r\n#define DEBUG_LED 2\r\n\r\nvoid signalError(int errorCode) {\r\n  for(int i = 0; i < errorCode; i++) {\r\n    digitalWrite(DEBUG_LED, HIGH);\r\n    delay(200);\r\n    digitalWrite(DEBUG_LED, LOW);\r\n    delay(200);\r\n  }\r\n  delay(1000);\r\n}\r\n```\r\n\r\n### 3. Logic Analyzers\r\n\r\nEssential for debugging:\r\n- I2C/SPI communication\r\n- Timing issues\r\n- Protocol verification\r\n\r\n**Recommended**: Saleae Logic Analyzer for professional work, or cheap Chinese clones for hobby projects.\r\n\r\n## Common Debugging Scenarios\r\n\r\n### Issue: I2C Device Not Responding\r\n\r\n**Debug Steps:**\r\n1. Check pull-up resistors (typically 4.7kŒ©)\r\n2. Scan I2C bus:\r\n\r\n```cpp\r\n#include <Wire.h>\r\n\r\nvoid scanI2C() {\r\n  Serial.println(\"Scanning I2C bus...\");\r\n  byte count = 0;\r\n  \r\n  for(byte i = 1; i < 127; i++) {\r\n    Wire.beginTransmission(i);\r\n    if(Wire.endTransmission() == 0) {\r\n      Serial.printf(\"Device found at 0x%02X\\n\", i);\r\n      count++;\r\n    }\r\n  }\r\n  Serial.printf(\"Found %d device(s)\\n\", count);\r\n}\r\n```\r\n\r\n3. Verify voltage levels (3.3V vs 5V)\r\n4. Check physical connections\r\n\r\n### Issue: Random Crashes/Resets\r\n\r\n**Common causes:**\r\n1. **Power issues**: Insufficient current, voltage drops\r\n2. **Stack overflow**: Check stack size\r\n3. **Watchdog timer**: Not being fed regularly\r\n4. **Memory leaks**: Monitor heap usage\r\n\r\n```cpp\r\n// Watchdog feeding\r\nvoid loop() {\r\n  feedWatchdog();  // Reset watchdog timer\r\n  \r\n  // Your code here\r\n  \r\n  // Monitor memory\r\n  if(ESP.getFreeHeap() < 10000) {\r\n    Serial.println(\"WARNING: Low memory!\");\r\n  }\r\n}\r\n```\r\n\r\n### Issue: Timing Problems\r\n\r\nUse built-in timers for precise measurements:\r\n\r\n```cpp\r\nunsigned long startTime, endTime;\r\n\r\nstartTime = micros();\r\nperformCriticalOperation();\r\nendTime = micros();\r\n\r\nSerial.printf(\"Operation took %lu ¬µs\\n\", endTime - startTime);\r\n```\r\n\r\n## Advanced Debugging Techniques\r\n\r\n### 1. Assert Statements\r\n\r\n```cpp\r\n#define ASSERT(condition, message) \\\r\n  if(!(condition)) { \\\r\n    Serial.printf(\"ASSERT FAILED: %s at %s:%d\\n\", \\\r\n                  message, __FILE__, __LINE__); \\\r\n    while(1); \\\r\n  }\r\n\r\nASSERT(temperature < 100, \"Temperature too high!\");\r\n```\r\n\r\n### 2. Memory Dumping\r\n\r\n```cpp\r\nvoid dumpMemory(uint8_t* addr, size_t len) {\r\n  for(size_t i = 0; i < len; i++) {\r\n    if(i % 16 == 0) Serial.printf(\"\\n%08X: \", (uint32_t)(addr + i));\r\n    Serial.printf(\"%02X \", addr[i]);\r\n  }\r\n  Serial.println();\r\n}\r\n```\r\n\r\n### 3. State Machines with Debug Output\r\n\r\n```cpp\r\nenum State {\r\n  INIT,\r\n  CONNECTING,\r\n  CONNECTED,\r\n  ERROR\r\n};\r\n\r\nState currentState = INIT;\r\n\r\nvoid setState(State newState) {\r\n  const char* stateNames[] = {\"INIT\", \"CONNECTING\", \"CONNECTED\", \"ERROR\"};\r\n  Serial.printf(\"State: %s -> %s\\n\", \r\n                stateNames[currentState], \r\n                stateNames[newState]);\r\n  currentState = newState;\r\n}\r\n```\r\n\r\n## Essential Hardware Tools\r\n\r\n### Must-Have\r\n1. **Multimeter**: Voltage, current, continuity checking\r\n2. **USB-to-Serial adapter**: For debugging without built-in USB\r\n3. **Cheap logic analyzer**: Protocol debugging\r\n4. **Oscilloscope**: For analog signals and noise issues\r\n\r\n### Nice-to-Have\r\n1. **Bench power supply**: Stable, adjustable power\r\n2. **Hot air station**: For SMD rework\r\n3. **Proper debugger**: ST-Link, J-Link for ARM debugging\r\n\r\n## Software Tools\r\n\r\n### Free & Essential\r\n- **Arduino IDE/PlatformIO**: Development and debugging\r\n- **PuTTY/CoolTerm**: Serial terminal\r\n- **Sigrok PulseView**: Logic analyzer software\r\n\r\n### Professional\r\n- **Segger Ozone**: Advanced debugging\r\n- **Percepio Tracealyzer**: RTOS debugging\r\n\r\n## Best Practices\r\n\r\n1. **Add debug code early**: Don't wait until things break\r\n2. **Use version control**: Track what changed when issues appeared\r\n3. **Document weird behaviors**: They often come back\r\n4. **Keep a debug log**: Track issues and solutions\r\n5. **Test incrementally**: Don't change too much at once\r\n\r\n## Debugging Workflow\r\n\r\n```\r\n1. Reproduce the issue consistently\r\n   ‚Üì\r\n2. Add logging around the problem area\r\n   ‚Üì\r\n3. Form a hypothesis\r\n   ‚Üì\r\n4. Test the hypothesis\r\n   ‚Üì\r\n5. Fix and verify\r\n   ‚Üì\r\n6. Document the solution\r\n```\r\n\r\n## Conclusion\r\n\r\nEmbedded debugging is part art, part science. The key is having the right tools and methodologies. Start with simple serial debugging, and gradually add more sophisticated tools as needed.\r\n\r\nRemember: **The best debugging tool is a clear understanding of your system.**\r\n\r\nHappy debugging! üîç\r\n";
export const html = "<h1>Debugging Embedded Systems: Tips and Tools</h1>\n<p>Debugging embedded systems presents unique challenges compared to traditional software development. Here's a comprehensive guide to the essential techniques and tools.</p>\n<h2>The Debugging Toolkit</h2>\n<h3>1. Serial Debugging: Your First Line of Defense</h3>\n<pre><code class=\"language-cpp\">// ESP32 example\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  Serial.println(\"System starting...\");\r\n}\r\n\r\nvoid loop() {\r\n  int sensorValue = analogRead(A0);\r\n  Serial.printf(\"Sensor: %d, Free heap: %d\\n\", \r\n                sensorValue, ESP.getFreeHeap());\r\n  delay(1000);\r\n}\n</code></pre>\n<p><strong>Pro tip</strong>: Use structured logging with prefixes:</p>\n<pre><code class=\"language-cpp\">#define DEBUG_SENSOR \"[SENSOR] \"\r\n#define DEBUG_NETWORK \"[NET] \"\r\n#define DEBUG_ERROR \"[ERROR] \"\r\n\r\nSerial.println(DEBUG_SENSOR \"Temperature: 25.4¬∞C\");\n</code></pre>\n<h3>2. LED Debugging: When Serial Isn't Available</h3>\n<p>The humble LED can save hours of debugging:</p>\n<pre><code class=\"language-cpp\">#define DEBUG_LED 2\r\n\r\nvoid signalError(int errorCode) {\r\n  for(int i = 0; i &#x3C; errorCode; i++) {\r\n    digitalWrite(DEBUG_LED, HIGH);\r\n    delay(200);\r\n    digitalWrite(DEBUG_LED, LOW);\r\n    delay(200);\r\n  }\r\n  delay(1000);\r\n}\n</code></pre>\n<h3>3. Logic Analyzers</h3>\n<p>Essential for debugging:</p>\n<ul>\n<li>I2C/SPI communication</li>\n<li>Timing issues</li>\n<li>Protocol verification</li>\n</ul>\n<p><strong>Recommended</strong>: Saleae Logic Analyzer for professional work, or cheap Chinese clones for hobby projects.</p>\n<h2>Common Debugging Scenarios</h2>\n<h3>Issue: I2C Device Not Responding</h3>\n<p><strong>Debug Steps:</strong></p>\n<ol>\n<li>Check pull-up resistors (typically 4.7kŒ©)</li>\n<li>Scan I2C bus:</li>\n</ol>\n<pre><code class=\"language-cpp\">#include &#x3C;Wire.h>\r\n\r\nvoid scanI2C() {\r\n  Serial.println(\"Scanning I2C bus...\");\r\n  byte count = 0;\r\n  \r\n  for(byte i = 1; i &#x3C; 127; i++) {\r\n    Wire.beginTransmission(i);\r\n    if(Wire.endTransmission() == 0) {\r\n      Serial.printf(\"Device found at 0x%02X\\n\", i);\r\n      count++;\r\n    }\r\n  }\r\n  Serial.printf(\"Found %d device(s)\\n\", count);\r\n}\n</code></pre>\n<ol start=\"3\">\n<li>Verify voltage levels (3.3V vs 5V)</li>\n<li>Check physical connections</li>\n</ol>\n<h3>Issue: Random Crashes/Resets</h3>\n<p><strong>Common causes:</strong></p>\n<ol>\n<li><strong>Power issues</strong>: Insufficient current, voltage drops</li>\n<li><strong>Stack overflow</strong>: Check stack size</li>\n<li><strong>Watchdog timer</strong>: Not being fed regularly</li>\n<li><strong>Memory leaks</strong>: Monitor heap usage</li>\n</ol>\n<pre><code class=\"language-cpp\">// Watchdog feeding\r\nvoid loop() {\r\n  feedWatchdog();  // Reset watchdog timer\r\n  \r\n  // Your code here\r\n  \r\n  // Monitor memory\r\n  if(ESP.getFreeHeap() &#x3C; 10000) {\r\n    Serial.println(\"WARNING: Low memory!\");\r\n  }\r\n}\n</code></pre>\n<h3>Issue: Timing Problems</h3>\n<p>Use built-in timers for precise measurements:</p>\n<pre><code class=\"language-cpp\">unsigned long startTime, endTime;\r\n\r\nstartTime = micros();\r\nperformCriticalOperation();\r\nendTime = micros();\r\n\r\nSerial.printf(\"Operation took %lu ¬µs\\n\", endTime - startTime);\n</code></pre>\n<h2>Advanced Debugging Techniques</h2>\n<h3>1. Assert Statements</h3>\n<pre><code class=\"language-cpp\">#define ASSERT(condition, message) \\\r\n  if(!(condition)) { \\\r\n    Serial.printf(\"ASSERT FAILED: %s at %s:%d\\n\", \\\r\n                  message, __FILE__, __LINE__); \\\r\n    while(1); \\\r\n  }\r\n\r\nASSERT(temperature &#x3C; 100, \"Temperature too high!\");\n</code></pre>\n<h3>2. Memory Dumping</h3>\n<pre><code class=\"language-cpp\">void dumpMemory(uint8_t* addr, size_t len) {\r\n  for(size_t i = 0; i &#x3C; len; i++) {\r\n    if(i % 16 == 0) Serial.printf(\"\\n%08X: \", (uint32_t)(addr + i));\r\n    Serial.printf(\"%02X \", addr[i]);\r\n  }\r\n  Serial.println();\r\n}\n</code></pre>\n<h3>3. State Machines with Debug Output</h3>\n<pre><code class=\"language-cpp\">enum State {\r\n  INIT,\r\n  CONNECTING,\r\n  CONNECTED,\r\n  ERROR\r\n};\r\n\r\nState currentState = INIT;\r\n\r\nvoid setState(State newState) {\r\n  const char* stateNames[] = {\"INIT\", \"CONNECTING\", \"CONNECTED\", \"ERROR\"};\r\n  Serial.printf(\"State: %s -> %s\\n\", \r\n                stateNames[currentState], \r\n                stateNames[newState]);\r\n  currentState = newState;\r\n}\n</code></pre>\n<h2>Essential Hardware Tools</h2>\n<h3>Must-Have</h3>\n<ol>\n<li><strong>Multimeter</strong>: Voltage, current, continuity checking</li>\n<li><strong>USB-to-Serial adapter</strong>: For debugging without built-in USB</li>\n<li><strong>Cheap logic analyzer</strong>: Protocol debugging</li>\n<li><strong>Oscilloscope</strong>: For analog signals and noise issues</li>\n</ol>\n<h3>Nice-to-Have</h3>\n<ol>\n<li><strong>Bench power supply</strong>: Stable, adjustable power</li>\n<li><strong>Hot air station</strong>: For SMD rework</li>\n<li><strong>Proper debugger</strong>: ST-Link, J-Link for ARM debugging</li>\n</ol>\n<h2>Software Tools</h2>\n<h3>Free &#x26; Essential</h3>\n<ul>\n<li><strong>Arduino IDE/PlatformIO</strong>: Development and debugging</li>\n<li><strong>PuTTY/CoolTerm</strong>: Serial terminal</li>\n<li><strong>Sigrok PulseView</strong>: Logic analyzer software</li>\n</ul>\n<h3>Professional</h3>\n<ul>\n<li><strong>Segger Ozone</strong>: Advanced debugging</li>\n<li><strong>Percepio Tracealyzer</strong>: RTOS debugging</li>\n</ul>\n<h2>Best Practices</h2>\n<ol>\n<li><strong>Add debug code early</strong>: Don't wait until things break</li>\n<li><strong>Use version control</strong>: Track what changed when issues appeared</li>\n<li><strong>Document weird behaviors</strong>: They often come back</li>\n<li><strong>Keep a debug log</strong>: Track issues and solutions</li>\n<li><strong>Test incrementally</strong>: Don't change too much at once</li>\n</ol>\n<h2>Debugging Workflow</h2>\n<pre><code>1. Reproduce the issue consistently\r\n   ‚Üì\r\n2. Add logging around the problem area\r\n   ‚Üì\r\n3. Form a hypothesis\r\n   ‚Üì\r\n4. Test the hypothesis\r\n   ‚Üì\r\n5. Fix and verify\r\n   ‚Üì\r\n6. Document the solution\n</code></pre>\n<h2>Conclusion</h2>\n<p>Embedded debugging is part art, part science. The key is having the right tools and methodologies. Start with simple serial debugging, and gradually add more sophisticated tools as needed.</p>\n<p>Remember: <strong>The best debugging tool is a clear understanding of your system.</strong></p>\n<p>Happy debugging! üîç</p>";
export const slug = "demo-debugging-embedded-systems";
export const type = "blog";

export default {
  frontmatter,
  content,
  html,
  slug,
  type
};

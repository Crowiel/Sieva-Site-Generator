<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TypeScript Best Practices for Large Projects</title>
  <link rel="stylesheet" href="../styles/main.css">
  <link rel="stylesheet" href="../styles/components.css">
  
</head>
<body>
  <header class="site-header">
    <nav class="nav">
      <div class="nav-brand">
        <a href="../">
          <span class="brand-name">Your Name</span>
          <span class="brand-subtitle">Automation & Embedded Systems</span>
        </a>
      </div>
      <button class="nav-toggle" id="navToggle" aria-label="Toggle navigation">
        <span class="hamburger"></span>
        <span class="hamburger"></span>
        <span class="hamburger"></span>
      </button>
      <ul class="nav-links">
        <li><a href="../">Home</a></li>
        <li><a href="../posts.html">Projects</a></li>
        <li><a href="../blog.html">Blog</a></li>
        <li><a href="../about.html">About</a></li>
      </ul>
      <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
        <div class="theme-toggle-track">
          <div class="theme-toggle-thumb"></div>
        </div>
      </button>
    </nav>
  </header>

  <!-- Floating Navigation (appears when scrolling) -->
  <nav class="floating-nav" id="floatingNav">
    <div class="floating-nav-buttons">
      <a href="../" class="floating-btn" title="Home">
        <span class="btn-icon">ğŸ </span>
        <span class="btn-text">Home</span>
      </a>
      <a href="../posts.html" class="floating-btn" title="Projects">
        <span class="btn-icon">ğŸ’¼</span>
        <span class="btn-text">Projects</span>
      </a>
      <a href="../blog.html" class="floating-btn" title="Blog">
        <span class="btn-icon">ğŸ“</span>
        <span class="btn-text">Blog</span>
      </a>
      <a href="../about.html" class="floating-btn" title="About">
        <span class="btn-icon">ğŸ‘¤</span>
        <span class="btn-text">About</span>
      </a>
      <button class="floating-btn theme-toggle" id="floatingThemeToggle" title="Toggle theme">
        <div class="theme-toggle-track">
          <div class="theme-toggle-thumb"></div>
        </div>
      </button>
    </div>
  </nav>

  <main class="main-content">
    
    <article class="blog-post">
      <header class="post-header">
        <h1>TypeScript Best Practices for Large Projects</h1>
        <div class="post-meta">
          <time>10.9.2024</time>
          
            <div class="tags">
              <a href="../tags/web%20development.html" class="tag">web development</a><a href="../tags/typescript.html" class="tag">typescript</a><a href="../tags/best%20practices.html" class="tag">best practices</a><a href="../tags/software%20architecture.html" class="tag">software architecture</a>
            </div>
          
        </div>
        
          <p class="post-description">Proven patterns and practices for maintaining type safety and code quality in large-scale TypeScript applications.</p>
        
      </header>

      <div class="post-content">
        <h1>TypeScript Best Practices for Large Projects</h1>
<p>TypeScript has become the de facto standard for large-scale JavaScript applications. Here are the patterns and practices that have helped me maintain sanity in complex codebases.</p>
<h2>Type Safety Foundations</h2>
<h3>1. Strict Mode is Non-Negotiable</h3>
<pre><code class="language-json">// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitThis": true,
    "alwaysStrict": true
  }
}
</code></pre>
<h3>2. Avoid <code>any</code> Like the Plague</h3>
<p>Instead of:</p>
<pre><code class="language-typescript">function processData(data: any) {
  return data.value;
}
</code></pre>
<p>Use proper types:</p>
<pre><code class="language-typescript">interface DataStructure {
  value: string;
  timestamp: number;
}

function processData(data: DataStructure) {
  return data.value;
}
</code></pre>
<h3>3. Use <code>unknown</code> for Truly Unknown Types</h3>
<pre><code class="language-typescript">function parseJSON(jsonString: string): unknown {
  return JSON.parse(jsonString);
}

// Force type checking before use
const data = parseJSON('{"name": "John"}');
if (typeof data === 'object' &#x26;&#x26; data !== null &#x26;&#x26; 'name' in data) {
  console.log(data.name);
}
</code></pre>
<h2>Advanced Type Patterns</h2>
<h3>Discriminated Unions</h3>
<p>Perfect for state management:</p>
<pre><code class="language-typescript">type LoadingState = 
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: string[] }
  | { status: 'error'; error: Error };

function handleState(state: LoadingState) {
  switch(state.status) {
    case 'idle':
      return 'Not started';
    case 'loading':
      return 'Loading...';
    case 'success':
      return state.data.join(', '); // TypeScript knows data exists
    case 'error':
      return state.error.message; // TypeScript knows error exists
  }
}
</code></pre>
<h3>Utility Types</h3>
<pre><code class="language-typescript">// Pick only needed properties
type UserPreview = Pick&#x3C;User, 'id' | 'name' | 'avatar'>;

// Make all properties optional
type PartialUser = Partial&#x3C;User>;

// Make all properties required
type RequiredUser = Required&#x3C;User>;

// Exclude properties
type UserWithoutPassword = Omit&#x3C;User, 'password'>;

// Create types from values
const CONFIG = {
  development: 'dev',
  staging: 'stg',
  production: 'prod'
} as const;

type Environment = typeof CONFIG[keyof typeof CONFIG];
// type Environment = "dev" | "stg" | "prod"
</code></pre>
<h3>Generic Constraints</h3>
<pre><code class="language-typescript">interface HasId {
  id: string;
}

function findById&#x3C;T extends HasId>(items: T[], id: string): T | undefined {
  return items.find(item => item.id === id);
}

// Works with any type that has an id
const user = findById(users, '123');
const product = findById(products, '456');
</code></pre>
<h2>Project Organization</h2>
<h3>Domain-Driven Structure</h3>
<pre><code>src/
â”œâ”€â”€ domains/
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ types.ts
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”œâ”€â”€ hooks.ts
â”‚   â”‚   â””â”€â”€ utils.ts
â”‚   â”œâ”€â”€ products/
â”‚   â””â”€â”€ orders/
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ types/
â”‚   â”œâ”€â”€ utils/
â”‚   â””â”€â”€ components/
â””â”€â”€ config/
</code></pre>
<h3>Centralized Type Definitions</h3>
<pre><code class="language-typescript">// shared/types/api.ts
export interface ApiResponse&#x3C;T> {
  data: T;
  status: number;
  message?: string;
}

export interface PaginatedResponse&#x3C;T> extends ApiResponse&#x3C;T[]> {
  pagination: {
    page: number;
    pageSize: number;
    total: number;
  };
}

// Usage
type UsersResponse = PaginatedResponse&#x3C;User>;
</code></pre>
<h2>Error Handling</h2>
<h3>Type-Safe Error Handling</h3>
<pre><code class="language-typescript">class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500
  ) {
    super(message);
    this.name = 'AppError';
  }
}

class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 'VALIDATION_ERROR', 400);
  }
}

function handleError(error: unknown): string {
  if (error instanceof ValidationError) {
    return `Validation failed: ${error.message}`;
  }
  if (error instanceof AppError) {
    return `Error ${error.code}: ${error.message}`;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return 'An unknown error occurred';
}
</code></pre>
<h2>API Integration</h2>
<h3>Type-Safe API Client</h3>
<pre><code class="language-typescript">interface ApiEndpoints {
  '/users': {
    GET: { response: User[] };
    POST: { body: CreateUserDto; response: User };
  };
  '/users/:id': {
    GET: { response: User };
    PUT: { body: UpdateUserDto; response: User };
    DELETE: { response: void };
  };
}

type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

async function apiCall&#x3C;
  Path extends keyof ApiEndpoints,
  Method extends keyof ApiEndpoints[Path] &#x26; HttpMethod
>(
  path: Path,
  method: Method,
  options?: ApiEndpoints[Path][Method] extends { body: infer B } ? { body: B } : never
): Promise&#x3C;ApiEndpoints[Path][Method] extends { response: infer R } ? R : never> {
  // Implementation
  throw new Error('Not implemented');
}

// Usage - fully type-safe!
const users = await apiCall('/users', 'GET');
const newUser = await apiCall('/users', 'POST', { 
  body: { name: 'John', email: 'john@example.com' } 
});
</code></pre>
<h2>Performance Tips</h2>
<h3>1. Use <code>const</code> Assertions</h3>
<pre><code class="language-typescript">// Without const assertion
const colors = ['red', 'green', 'blue'];
// type: string[]

// With const assertion
const colors = ['red', 'green', 'blue'] as const;
// type: readonly ["red", "green", "blue"]
</code></pre>
<h3>2. Lazy Type Inference</h3>
<pre><code class="language-typescript">// Avoid
const data: ComplexType = await fetchData();

// Better - let TypeScript infer
const data = await fetchData();
// TypeScript infers the type automatically
</code></pre>
<h2>Testing</h2>
<h3>Type-Safe Test Utilities</h3>
<pre><code class="language-typescript">import { expect, test } from 'vitest';

function expectType&#x3C;T>(value: T): void {}

test('user object has correct shape', () => {
  const user = createUser();
  
  // Runtime check
  expect(user).toHaveProperty('id');
  
  // Compile-time check
  expectType&#x3C;User>(user);
});
</code></pre>
<h2>Common Pitfalls</h2>
<h3>1. Over-Engineering Types</h3>
<pre><code class="language-typescript">// Bad - too complex
type SuperComplexType&#x3C;T extends Record&#x3C;string, any>> = {
  [K in keyof T]: T[K] extends Function 
    ? ReturnType&#x3C;T[K]> 
    : T[K] extends object 
      ? SuperComplexType&#x3C;T[K]> 
      : T[K];
};

// Good - simple and clear
type SimplifiedType&#x3C;T> = {
  [K in keyof T]: T[K];
};
</code></pre>
<h3>2. Not Using Enums Wisely</h3>
<pre><code class="language-typescript">// Prefer union types over enums
type Status = 'pending' | 'approved' | 'rejected';

// Instead of
enum Status {
  Pending = 'pending',
  Approved = 'approved',
  Rejected = 'rejected'
}
</code></pre>
<h2>Conclusion</h2>
<p>TypeScript's power comes from its type system. Use it wisely:</p>
<ol>
<li><strong>Start strict</strong> - Enable all strict checks</li>
<li><strong>Think in types</strong> - Model your domain accurately</li>
<li><strong>Keep it simple</strong> - Don't over-engineer</li>
<li><strong>Document with types</strong> - They're self-documenting</li>
<li><strong>Test types</strong> - Use tools like <code>tsd</code> for type tests</li>
</ol>
<p>The goal is code that's impossible to misuse, not just correct code.</p>
<p>Happy typing! âŒ¨ï¸</p>
      </div>

      <footer class="post-footer">
        <a href="../blog.html" class="back-link">â† Back to Blog</a>
      </footer>
    </article>
  
  </main>

  <footer class="site-footer">
    <p>&copy; 2025 Your Name. Automation Engineer & Embedded Systems Developer</p>
    <p class="generator-credit">
      Generated with <a href="https://github.com/Crowiel/Sieva-Site-Generator" target="_blank" rel="noopener">SievÃ¤ Site Generator</a>
    </p>
  </footer>

  <script src="../static/js/components.js"></script>
  <script src="../static/js/gallery.js"></script>
</body>
</html>

<!-- 
  Generated with SievÃ¤ Site Generator
  https://github.com/Crowiel/Sieva-Site-Generator
  A modern static site generator built with Deno, TypeScript, and MDX
-->